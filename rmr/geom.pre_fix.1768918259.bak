#include "pai_geom.h"
#include "pai_scan.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifndef PAI_CAST_HELPERS
#define PAI_CAST_HELPERS
#define F32(x) ((float)(x))
#define SZ(x)  ((size_t)(x))
#endif


#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

typedef struct {
    int size;
    const char *out;
    int do_cycle42;
    int do_sin30;
    int do_sqrt2;
    int do_sqrt3;
    int do_fibo;
    int do_shapes;
    int do_mandel;
    float w_shapes;
    float w_mandel;
    int max_iter;
} geom_opt;

static void *xmalloc(size_t n) {
    void *p = malloc(n);
    if(!p) { perror("malloc"); exit(2); }
    memset(p, 0, n);
    return p;
}

static unsigned char u8_clamp(float x) {
    if(x < 0.0f) x = 0.0f;
    if(x > 1.0f) x = 1.0f;
    int v = (int)lrintf(x * 255.0f);
    if(v < 0) v = 0;
    if(v > 255) v = 255;
    return (unsigned char)v;
}

static int write_pgm(const char *path, const float *img01, int n) {
    FILE *f = fopen(path, "wb");
    if(!f) return -1;
    fprintf(f, "P5\n%d %d\n255\n", n, n);
    for(int i=0;i<n*n;i++) {
        unsigned char v = u8_clamp(img01[i]);
        fwrite(&v, 1, 1, f);
    }
    fclose(f);
    return 0;
}

static inline float f01(float x) {
    if(x < 0.0f) return 0.0f;
    if(x > 1.0f) return 1.0f;
    return x;
}

static void overlay_shapes(float *out01, int n) {
    // Normalizado: coord em [-1,1]
    const float cx = (F32(n) - 1.0f) * 0.5f;
    const float cy = (F32(n) - 1.0f) * 0.5f;
    const float s = (F32(n) * 0.5f);

    for(int y=0;y<n;y++) {
        for(int x=0;x<n;x++) {
            const float fx = (float)x;
            const float X = (fx - cx)/s;
            const float fy = (float)y;
            const float Y = (fy - cy)/s;
            float r2 = X*X + Y*Y;

            // circle (r <= 0.95)
            float circle = (r2 <= (0.95f*0.95f)) ? 1.0f : 0.0f;

            // square (|x|<=0.70, |y|<=0.70) rotacionado 45° -> losango
            float ax = fabsf(X), ay = fabsf(Y);
            float diamond = ((ax + ay) <= 0.95f) ? 1.0f : 0.0f;

            // triangle (equilátero) aproximado por half-planes
            // vtx: (0,0.88), (-0.76,-0.44), (0.76,-0.44)
            float tri = 1.0f;
            {
                float x1=0.0f,  y1=0.88f;
                float x2=-0.76f,y2=-0.44f;
                float x3=0.76f, y3=-0.44f;
                // barycentric sign
                float d1 = (X-x2)*(y1-y2) - (Y-y2)*(x1-x2);
                float d2 = (X-x3)*(y2-y3) - (Y-y3)*(x2-x3);
                float d3 = (X-x1)*(y3-y1) - (Y-y1)*(x3-x1);
                int has_neg = (d1<0) || (d2<0) || (d3<0);
                int has_pos = (d1>0) || (d2>0) || (d3>0);
                tri = !(has_neg && has_pos) ? 1.0f : 0.0f;
            }

            // hexagon: |x| + |y|/sqrt(3) <= a  (aprox)
            float hex = ((ax + ay/1.7320508f) <= 0.95f) ? 1.0f : 0.0f;

            float ov = fmaxf(tri, fmaxf(diamond, fmaxf(hex, circle)));
            ov *= circle; // recorte circular

            out01[y*n + x] = ov;
        }
    }
}

static void mandelbrot_field(float *out01, int n, int max_iter) {
    // janela padrão
    float cx = -0.5f, cy = 0.0f;
    float scale = 2.8f;

    for(int y=0;y<n;y++) {
        float im = cy + scale * ((float)y/(F32(n)-1.0f) - 0.5f);
        for(int x=0;x<n;x++) {
            float re = cx + scale * ((float)x/(F32(n)-1.0f) - 0.5f);

            float zr = 0.0f, zi = 0.0f;
            int it = 0;
            for(; it<max_iter; ++it) {
                float zr2 = zr*zr - zi*zi + re;
                float zi2 = 2.0f*zr*zi + im;
                zr = zr2; zi = zi2;
                if(zr*zr + zi*zi > 4.0f) break;
            }

            float t = (float)it / (float)max_iter;
            float v = 1.0f - sqrtf(t);
            out01[y*n + x] = f01(v);
        }
    }
}

static float fibo_phase(int k) {
    // Fibonacci discreta como fase (não “régua”, só sequência)
    // Usa razão áurea para modularizar em [0,1)
    const float phi = 1.61803398875f;
    float x = fmodf((float)k * phi, 1.0f);
    if(x < 0.0f) x += 1.0f;
    return x;
}

static void add_cycle42(float *img01, int n) {
    // amostra circular 42 passos e injeta como “anel”
    const float cx = (F32(n) - 1.0f) * 0.5f;
    const float cy = (F32(n) - 1.0f) * 0.5f;
    float R  = 0.93f*(F32(n) * 0.5f);

    for(int k=0;k<42;k++) {
        float th = 2.0f*(float)M_PI*(float)k/42.0f;
        float x = cx + R*cosf(th);
        float y = cy + R*sinf(th);
        int xi = (int)lrintf(x);
        int yi = (int)lrintf(y);
        if(xi<0||xi>=n||yi<0||yi>=n) continue;
        img01[yi*n + xi] = 1.0f;
    }
}

static void add_sin30_sqrt(float *img01, int n, int do_sin30, int do_sqrt2, int do_sqrt3, int do_fibo) {
    // Desenha “traços” e relações (não dogma, só marcadores)
    float cx = (F32(n) - 1.0f) * 0.5f, cy = (F32(n) - 1.0f) * 0.5f;
    float R  = 0.85f*(F32(n) * 0.5f);

    // sin(30)=0.5 -> y = 0.5R no círculo
    if(do_sin30) {
        int y = (int)lrintf(cy - 0.5f*R);
        for(int x=0;x<n;x++) {
            img01[y*n + x] = fmaxf(img01[y*n + x], 0.85f);
        }
    }

    // sqrt2 diagonal (quadrado): linha y=x
    if(do_sqrt2) {
        for(int i=0;i<n;i++) {
            img01[i*n + i] = 1.0f;
        }
    }

    // sqrt3/2: “altura” do triângulo equilátero: h = (sqrt3/2)*lado
    if(do_sqrt3) {
        float h = 0.8660254f * R;
        int y = (int)lrintf(cy - h);
        if(y>=0 && y<n) {
            for(int x=0;x<n;x++) img01[y*n + x] = fmaxf(img01[y*n + x], 0.65f);
        }
    }

    // Fibonacci: variação angular discreta
    if(do_fibo) {
        for(int k=0;k<144;k++) {
            float ph = fibo_phase(k);
            float th = 2.0f*(float)M_PI*ph;
            float rr = (0.15f + 0.80f*ph) * (F32(n) * 0.5f);
            int xi = (int)lrintf(cx + rr*cosf(th));
            int yi = (int)lrintf(cy + rr*sinf(th));
            if(xi<0||xi>=n||yi<0||yi>=n) continue;
            img01[yi*n + xi] = fmaxf(img01[yi*n + xi], 0.75f);
        }
    }
}

static void blend(float *dst, const float *a, const float *b, int n, float wa, float wb) {
    for(size_t i=0; i < N; i++) {
        float v = wa*a[i] + wb*b[i];
        dst[i] = f01(v);
    }
}

static void write_report(const char *out_dir, const geom_opt *o) {
    char path[PAI_MAX_PATH];
    snprintf(path, sizeof(path), "%s/report.txt", out_dir);
    FILE *f = fopen(path, "wb");
    if(!f) return;

    fprintf(f, "PAI :: geom report\n");
    fprintf(f, "size=%d\n", o->size);
    fprintf(f, "flags: cycle42=%d sin30=%d sqrt2=%d sqrt3=%d fibo=%d shapes=%d mandel=%d\n",
        o->do_cycle42, o->do_sin30, o->do_sqrt2, o->do_sqrt3, o->do_fibo, o->do_shapes, o->do_mandel);
    fprintf(f, "weights: w_shapes=%.3f w_mandel=%.3f max_iter=%d\n", o->w_shapes, o->w_mandel, o->max_iter);

    // notas numéricas (sem régua fixa)
    fprintf(f, "\nnotes:\n");
    fprintf(f, " - sin(30)=0.5 marker line if enabled\n");
    fprintf(f, " - sqrt2 diagonal marker if enabled\n");
    fprintf(f, " - sqrt3/2 height marker if enabled\n");
    fprintf(f, " - cycle42 draws 42 samples on the ring\n");
    fprintf(f, " - fibo draws 144 phase points using phi modular phase\n");

    fclose(f);
    printf("[OK] report: %s\n", path);
}

int pai_cmd_geom(int argc, char **argv) {
    geom_opt o;
    memset(&o, 0, sizeof(o));
    o.size = 768;
    o.out = "out_geom";
    o.w_shapes = 0.55f;
    o.w_mandel = 0.45f;
    o.max_iter = 360;

    for(int i=2;i<argc;i++) {
        if(!strcmp(argv[i],"--out") && i+1<argc) o.out = argv[++i];
        else if(!strcmp(argv[i],"--size") && i+1<argc) o.size = atoi(argv[++i]);
        else if(!strcmp(argv[i],"--cycle42")) o.do_cycle42 = 1;
        else if(!strcmp(argv[i],"--sin30")) o.do_sin30 = 1;
        else if(!strcmp(argv[i],"--sqrt2")) o.do_sqrt2 = 1;
        else if(!strcmp(argv[i],"--sqrt3")) o.do_sqrt3 = 1;
        else if(!strcmp(argv[i],"--fibo"))  o.do_fibo = 1;
        else if(!strcmp(argv[i],"--shapes")) o.do_shapes = 1;
        else if(!strcmp(argv[i],"--mandel")) o.do_mandel = 1;
        else if(!strcmp(argv[i],"--w-shapes") && i+1<argc) o.w_shapes = (float)atof(argv[++i]);
        else if(!strcmp(argv[i],"--w-mandel") && i+1<argc) o.w_mandel = (float)atof(argv[++i]);
        else if(!strcmp(argv[i],"--max-iter") && i+1<argc) o.max_iter = atoi(argv[++i]);
    }

    if(o.size < 64) o.size = 64;
    if(o.size > 4096) o.size = 4096;

    pai_mkdir_p(o.out);

    int n = o.size;
    size_t N = SZ(n) * SZ(n);
    float *ov = (float*)xmalloc(N * sizeof(float));
    float *mb = (float*)xmalloc(N * sizeof(float));
    float *gf = (float*)xmalloc(N * sizeof(float));

    // shapes
    if(o.do_shapes) overlay_shapes(ov, n);
    else memset(ov, 0, N * sizeof(float));

    // mandel
    if(o.do_mandel) mandelbrot_field(mb, n, o.max_iter);
    else memset(mb, 0, N * sizeof(float));

    // blend
    blend(gf, ov, mb, n, o.w_shapes, o.w_mandel);

    // add markers
    if(o.do_cycle42) add_cycle42(gf, n);
    add_sin30_sqrt(gf, n, o.do_sin30, o.do_sqrt2, o.do_sqrt3, o.do_fibo);

    char p1[PAI_MAX_PATH], p2[PAI_MAX_PATH], p3[PAI_MAX_PATH];
    snprintf(p1, sizeof(p1), "%s/overlay.pgm", o.out);
    snprintf(p2, sizeof(p2), "%s/mandel.pgm", o.out);
    snprintf(p3, sizeof(p3), "%s/geom.pgm",   o.out);

    if(write_pgm(p1, ov, n)!=0) fprintf(stderr,"[warn] nao escreveu %s\n", p1);
    if(write_pgm(p2, mb, n)!=0) fprintf(stderr,"[warn] nao escreveu %s\n", p2);
    if(write_pgm(p3, gf, n)!=0) fprintf(stderr,"[warn] nao escreveu %s\n", p3);

    printf("[OK] overlay: %s\n", p1);
    printf("[OK] mandel:  %s\n", p2);
    printf("[OK] geom:    %s\n", p3);

    write_report(o.out, &o);

    free(ov); free(mb); free(gf);
    return 0;
}
