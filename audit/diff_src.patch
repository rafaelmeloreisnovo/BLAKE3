diff --git a/src/ffi_avx2.rs b/src/ffi_avx2.rs
index ef954bd..81a721d 100644
--- a/src/ffi_avx2.rs
+++ b/src/ffi_avx2.rs
@@ -4,6 +4,7 @@ use crate::{CVWords, IncrementCounter, BLOCK_LEN, OUT_LEN};
 // compress_xof.
 
 // Unsafe because this may only be called on platforms supporting AVX2.
+#[inline]
 pub unsafe fn hash_many<const N: usize>(
     inputs: &[&[u8; N]],
     key: &CVWords,
@@ -35,7 +36,7 @@ pub unsafe fn hash_many<const N: usize>(
 }
 
 pub mod ffi {
-    unsafe extern "C" {
+    extern "C" {
         pub fn blake3_hash_many_avx2(
             inputs: *const *const u8,
             num_inputs: usize,
diff --git a/src/ffi_avx512.rs b/src/ffi_avx512.rs
index c83048e..933bfb6 100644
--- a/src/ffi_avx512.rs
+++ b/src/ffi_avx512.rs
@@ -1,6 +1,7 @@
 use crate::{CVWords, IncrementCounter, BLOCK_LEN, OUT_LEN};
 
 // Unsafe because this may only be called on platforms supporting AVX-512.
+#[inline]
 pub unsafe fn compress_in_place(
     cv: &mut CVWords,
     block: &[u8; BLOCK_LEN],
@@ -20,6 +21,7 @@ pub unsafe fn compress_in_place(
 }
 
 // Unsafe because this may only be called on platforms supporting AVX-512.
+#[inline]
 pub unsafe fn compress_xof(
     cv: &CVWords,
     block: &[u8; BLOCK_LEN],
@@ -42,6 +44,7 @@ pub unsafe fn compress_xof(
 }
 
 // Unsafe because this may only be called on platforms supporting AVX-512.
+#[inline]
 pub unsafe fn hash_many<const N: usize>(
     inputs: &[&[u8; N]],
     key: &CVWords,
@@ -74,6 +77,7 @@ pub unsafe fn hash_many<const N: usize>(
 
 // Unsafe because this may only be called on platforms supporting AVX-512.
 #[cfg(unix)]
+#[inline]
 pub unsafe fn xof_many(
     cv: &CVWords,
     block: &[u8; BLOCK_LEN],
@@ -97,7 +101,7 @@ pub unsafe fn xof_many(
 }
 
 pub mod ffi {
-    unsafe extern "C" {
+    extern "C" {
         pub fn blake3_compress_in_place_avx512(
             cv: *mut u32,
             block: *const u8,
diff --git a/src/ffi_neon.rs b/src/ffi_neon.rs
index 6112b1b..fec8a0d 100644
--- a/src/ffi_neon.rs
+++ b/src/ffi_neon.rs
@@ -1,6 +1,7 @@
 use crate::{CVWords, IncrementCounter, BLOCK_LEN, OUT_LEN};
 
 // Unsafe because this may only be called on platforms supporting NEON.
+#[inline]
 pub unsafe fn hash_many<const N: usize>(
     inputs: &[&[u8; N]],
     key: &CVWords,
@@ -35,7 +36,7 @@ pub unsafe fn hash_many<const N: usize>(
 // implementation only provides 4x compression, and it relies on the portable
 // implementation for 1x compression. However, we expose the portable Rust
 // implementation here instead, to avoid linking in unnecessary code.
-#[unsafe(no_mangle)]
+#[no_mangle]
 pub extern "C" fn blake3_compress_in_place_portable(
     cv: *mut u32,
     block: *const u8,
@@ -55,7 +56,7 @@ pub extern "C" fn blake3_compress_in_place_portable(
 }
 
 pub mod ffi {
-    unsafe extern "C" {
+    extern "C" {
         pub fn blake3_hash_many_neon(
             inputs: *const *const u8,
             num_inputs: usize,
diff --git a/src/ffi_sse2.rs b/src/ffi_sse2.rs
index 78f09b8..decbc86 100644
--- a/src/ffi_sse2.rs
+++ b/src/ffi_sse2.rs
@@ -1,6 +1,7 @@
 use crate::{CVWords, IncrementCounter, BLOCK_LEN, OUT_LEN};
 
 // Unsafe because this may only be called on platforms supporting SSE2.
+#[inline]
 pub unsafe fn compress_in_place(
     cv: &mut CVWords,
     block: &[u8; BLOCK_LEN],
@@ -20,6 +21,7 @@ pub unsafe fn compress_in_place(
 }
 
 // Unsafe because this may only be called on platforms supporting SSE2.
+#[inline]
 pub unsafe fn compress_xof(
     cv: &CVWords,
     block: &[u8; BLOCK_LEN],
@@ -42,6 +44,7 @@ pub unsafe fn compress_xof(
 }
 
 // Unsafe because this may only be called on platforms supporting SSE2.
+#[inline]
 pub unsafe fn hash_many<const N: usize>(
     inputs: &[&[u8; N]],
     key: &CVWords,
@@ -73,7 +76,7 @@ pub unsafe fn hash_many<const N: usize>(
 }
 
 pub mod ffi {
-    unsafe extern "C" {
+    extern "C" {
         pub fn blake3_compress_in_place_sse2(
             cv: *mut u32,
             block: *const u8,
diff --git a/src/ffi_sse41.rs b/src/ffi_sse41.rs
index 77ab89a..dde99e3 100644
--- a/src/ffi_sse41.rs
+++ b/src/ffi_sse41.rs
@@ -1,6 +1,7 @@
 use crate::{CVWords, IncrementCounter, BLOCK_LEN, OUT_LEN};
 
 // Unsafe because this may only be called on platforms supporting SSE4.1.
+#[inline]
 pub unsafe fn compress_in_place(
     cv: &mut CVWords,
     block: &[u8; BLOCK_LEN],
@@ -20,6 +21,7 @@ pub unsafe fn compress_in_place(
 }
 
 // Unsafe because this may only be called on platforms supporting SSE4.1.
+#[inline]
 pub unsafe fn compress_xof(
     cv: &CVWords,
     block: &[u8; BLOCK_LEN],
@@ -42,6 +44,7 @@ pub unsafe fn compress_xof(
 }
 
 // Unsafe because this may only be called on platforms supporting SSE4.1.
+#[inline]
 pub unsafe fn hash_many<const N: usize>(
     inputs: &[&[u8; N]],
     key: &CVWords,
@@ -73,7 +76,7 @@ pub unsafe fn hash_many<const N: usize>(
 }
 
 pub mod ffi {
-    unsafe extern "C" {
+    extern "C" {
         pub fn blake3_compress_in_place_sse41(
             cv: *mut u32,
             block: *const u8,
diff --git a/src/guts.rs b/src/guts.rs
index 6bbf5a5..158446b 100644
--- a/src/guts.rs
+++ b/src/guts.rs
@@ -8,6 +8,7 @@ pub struct ChunkState(crate::ChunkState);
 impl ChunkState {
     // Currently this type only supports the regular hash mode. If an
     // incremental user needs keyed_hash or derive_key, we can add that.
+    #[inline]
     pub fn new(chunk_counter: u64) -> Self {
         Self(crate::ChunkState::new(
             crate::IV,
@@ -28,6 +29,7 @@ impl ChunkState {
         self
     }
 
+    #[inline]
     pub fn finalize(&self, is_root: bool) -> crate::Hash {
         let output = self.0.output();
         if is_root {
@@ -40,6 +42,7 @@ impl ChunkState {
 
 // As above, this currently assumes the regular hash mode. If an incremental
 // user needs keyed_hash or derive_key, we can add that.
+#[inline]
 pub fn parent_cv(
     left_child: &crate::Hash,
     right_child: &crate::Hash,
diff --git a/src/hazmat.rs b/src/hazmat.rs
index 1dfe8f3..18e276b 100644
--- a/src/hazmat.rs
+++ b/src/hazmat.rs
@@ -455,6 +455,7 @@ fn merge_subtrees_inner(
 /// [`Hasher::finalize_non_root`](HasherExt::finalize_non_root) or other calls to
 /// `merge_subtrees_non_root`. "Chaining value" is the academic term for a non-root or non-final
 /// hash.
+#[inline]
 pub fn merge_subtrees_non_root(
     left_child: &ChainingValue,
     right_child: &ChainingValue,
@@ -473,6 +474,7 @@ pub fn merge_subtrees_non_root(
 /// Note that inputs of [`CHUNK_LEN`] or less don't produce any parent nodes and can't be hashed
 /// using this function. In that case you must get the root hash from [`Hasher::finalize`] (or just
 /// [`blake3::hash`](crate::hash)).
+#[inline]
 pub fn merge_subtrees_root(
     left_child: &ChainingValue,
     right_child: &ChainingValue,
@@ -523,6 +525,7 @@ pub fn merge_subtrees_root(
 /// hasher.finalize_xof().fill(&mut expected);
 /// assert_eq!(output_bytes, expected);
 /// ```
+#[inline]
 pub fn merge_subtrees_root_xof(
     left_child: &ChainingValue,
     right_child: &ChainingValue,
@@ -556,6 +559,7 @@ pub type ContextKey = [u8; KEY_LEN];
 ///
 /// assert_eq!(derived_key, blake3::derive_key("foo", b"bar"));
 /// ```
+#[inline]
 pub fn hash_derive_key_context(context: &str) -> ContextKey {
     crate::hash_all_at_once::<crate::join::SerialJoin>(
         context.as_bytes(),
diff --git a/src/join.rs b/src/join.rs
index 862ebcf..e42e830 100644
--- a/src/join.rs
+++ b/src/join.rs
@@ -37,7 +37,7 @@ pub trait Join {
 pub enum SerialJoin {}
 
 impl Join for SerialJoin {
-    #[inline]
+    #[inline(always)]
     fn join<A, B, RA, RB>(oper_a: A, oper_b: B) -> (RA, RB)
     where
         A: FnOnce() -> RA + Send,
@@ -59,7 +59,7 @@ pub enum RayonJoin {}
 
 #[cfg(feature = "rayon")]
 impl Join for RayonJoin {
-    #[inline]
+    #[inline(always)]
     fn join<A, B, RA, RB>(oper_a: A, oper_b: B) -> (RA, RB)
     where
         A: FnOnce() -> RA + Send,
diff --git a/src/lib.rs b/src/lib.rs
index f27f903..d777896 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -32,14 +32,17 @@
 //!
 //! # Cargo Features
 //!
-//! The `std` feature (the only feature enabled by default) enables the
-//! [`Write`] implementation and the [`update_reader`](Hasher::update_reader)
-//! method for [`Hasher`], and also the [`Read`] and [`Seek`] implementations
-//! for [`OutputReader`].
+//! The `std` feature (the only feature enabled by default) is required for
+//! implementations of the [`Write`] and [`Seek`] traits, the
+//! [`update_reader`](Hasher::update_reader) helper method, and runtime CPU
+//! feature detection on x86. If this feature is disabled, the only way to use
+//! the x86 SIMD implementations is to enable the corresponding instruction sets
+//! globally, with e.g. `RUSTFLAGS="-C target-cpu=native"`. The resulting binary
+//! will not be portable to other machines.
 //!
 //! The `rayon` feature (disabled by default, but enabled for [docs.rs]) adds
 //! the [`update_rayon`](Hasher::update_rayon) and (in combination with `mmap`
-//! below) [`update_mmap_rayon`](Hasher::update_mmap_rayon) methods for
+//! below) [`update_mmap_rayon`](Hasher::update_mmap_rayon) methods, for
 //! multithreaded hashing. However, even if this feature is enabled, all other
 //! APIs remain single-threaded.
 //!
@@ -79,7 +82,6 @@
 //! [BLAKE3]: https://blake3.io
 //! [Rayon]: https://github.com/rayon-rs/rayon
 //! [docs.rs]: https://docs.rs/
-//! [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html
 //! [`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html
 //! [`Seek`]: https://doc.rust-lang.org/std/io/trait.Seek.html
 //! [`digest`]: https://crates.io/crates/digest
@@ -253,14 +255,6 @@ impl Hash {
         Self(bytes)
     }
 
-    /// The raw bytes of the `Hash`, as a slice. Useful for serialization. Note that byte arrays
-    /// don't provide constant-time equality checking, so if you need to compare hashes, prefer
-    /// the `Hash` type.
-    #[inline]
-    pub const fn as_slice(&self) -> &[u8] {
-        self.0.as_slice()
-    }
-
     /// Create a `Hash` from its raw bytes representation as a slice.
     ///
     /// Returns an error if the slice is not exactly 32 bytes long.
diff --git a/src/platform.rs b/src/platform.rs
index 3a05420..5507cc1 100644
--- a/src/platform.rs
+++ b/src/platform.rs
@@ -62,6 +62,7 @@ pub enum Platform {
 
 impl Platform {
     #[allow(unreachable_code)]
+    #[inline]
     pub fn detect() -> Self {
         #[cfg(miri)]
         {
@@ -99,6 +100,7 @@ impl Platform {
         Platform::Portable
     }
 
+    #[inline]
     pub fn simd_degree(&self) -> usize {
         let degree = match self {
             Platform::Portable => 1,
@@ -120,6 +122,7 @@ impl Platform {
         degree
     }
 
+    #[inline]
     pub fn compress_in_place(
         &self,
         cv: &mut CVWords,
@@ -156,6 +159,7 @@ impl Platform {
         }
     }
 
+    #[inline]
     pub fn compress_xof(
         &self,
         cv: &CVWords,
@@ -349,11 +353,13 @@ impl Platform {
 
     // Explicit platform constructors, for benchmarks.
 
+    #[inline]
     pub fn portable() -> Self {
         Self::Portable
     }
 
     #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+    #[inline]
     pub fn sse2() -> Option<Self> {
         if sse2_detected() {
             Some(Self::SSE2)
@@ -363,6 +369,7 @@ impl Platform {
     }
 
     #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+    #[inline]
     pub fn sse41() -> Option<Self> {
         if sse41_detected() {
             Some(Self::SSE41)
@@ -372,6 +379,7 @@ impl Platform {
     }
 
     #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+    #[inline]
     pub fn avx2() -> Option<Self> {
         if avx2_detected() {
             Some(Self::AVX2)
@@ -382,6 +390,7 @@ impl Platform {
 
     #[cfg(blake3_avx512_ffi)]
     #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+    #[inline]
     pub fn avx512() -> Option<Self> {
         if avx512_detected() {
             Some(Self::AVX512)
@@ -391,12 +400,14 @@ impl Platform {
     }
 
     #[cfg(blake3_neon)]
+    #[inline]
     pub fn neon() -> Option<Self> {
         // Assumed to be safe if the "neon" feature is on.
         Some(Self::NEON)
     }
 
     #[cfg(blake3_wasm32_simd)]
+    #[inline]
     pub fn wasm32_simd() -> Option<Self> {
         // Assumed to be safe if the "wasm32_simd" feature is on.
         Some(Self::WASM32_SIMD)
diff --git a/src/portable.rs b/src/portable.rs
index 7af6828..0c68d54 100644
--- a/src/portable.rs
+++ b/src/portable.rs
@@ -74,6 +74,7 @@ fn compress_pre(
     state
 }
 
+#[inline]
 pub fn compress_in_place(
     cv: &mut CVWords,
     block: &[u8; BLOCK_LEN],
@@ -93,6 +94,7 @@ pub fn compress_in_place(
     cv[7] = state[7] ^ state[15];
 }
 
+#[inline]
 pub fn compress_xof(
     cv: &CVWords,
     block: &[u8; BLOCK_LEN],
@@ -120,6 +122,7 @@ pub fn compress_xof(
     crate::platform::le_bytes_from_words_64(&state)
 }
 
+#[inline]
 pub fn hash1<const N: usize>(
     input: &[u8; N],
     key: &CVWords,
@@ -150,6 +153,7 @@ pub fn hash1<const N: usize>(
     *out = crate::platform::le_bytes_from_words_32(&cv);
 }
 
+#[inline]
 pub fn hash_many<const N: usize>(
     inputs: &[&[u8; N]],
     key: &CVWords,
diff --git a/src/rust_avx2.rs b/src/rust_avx2.rs
index 1029e7a..d6eb435 100644
--- a/src/rust_avx2.rs
+++ b/src/rust_avx2.rs
@@ -312,6 +312,7 @@ unsafe fn load_counters(counter: u64, increment_counter: IncrementCounter) -> (_
     }
 }
 
+#[inline]
 #[target_feature(enable = "avx2")]
 pub unsafe fn hash8(
     inputs: &[*const u8; DEGREE],
@@ -400,6 +401,7 @@ pub unsafe fn hash8(
 }
 
 #[target_feature(enable = "avx2")]
+#[inline]
 pub unsafe fn hash_many<const N: usize>(
     mut inputs: &[&[u8; N]],
     key: &CVWords,
diff --git a/src/rust_sse2.rs b/src/rust_sse2.rs
index f411d87..e25a305 100644
--- a/src/rust_sse2.rs
+++ b/src/rust_sse2.rs
@@ -345,6 +345,7 @@ unsafe fn compress_pre(
 }
 
 #[target_feature(enable = "sse2")]
+#[inline]
 pub unsafe fn compress_in_place(
     cv: &mut CVWords,
     block: &[u8; BLOCK_LEN],
@@ -360,6 +361,7 @@ pub unsafe fn compress_in_place(
 }
 
 #[target_feature(enable = "sse2")]
+#[inline]
 pub unsafe fn compress_xof(
     cv: &CVWords,
     block: &[u8; BLOCK_LEN],
@@ -579,6 +581,7 @@ unsafe fn load_counters(counter: u64, increment_counter: IncrementCounter) -> (_
 }
 
 #[target_feature(enable = "sse2")]
+#[inline]
 pub unsafe fn hash4(
     inputs: &[*const u8; DEGREE],
     blocks: usize,
@@ -670,6 +673,7 @@ pub unsafe fn hash4(
 }
 
 #[target_feature(enable = "sse2")]
+#[inline(always)]
 unsafe fn hash1<const N: usize>(
     input: &[u8; N],
     key: &CVWords,
@@ -703,6 +707,7 @@ unsafe fn hash1<const N: usize>(
 }
 
 #[target_feature(enable = "sse2")]
+#[inline]
 pub unsafe fn hash_many<const N: usize>(
     mut inputs: &[&[u8; N]],
     key: &CVWords,
diff --git a/src/rust_sse41.rs b/src/rust_sse41.rs
index 2623cfe..bd1c525 100644
--- a/src/rust_sse41.rs
+++ b/src/rust_sse41.rs
@@ -334,6 +334,7 @@ unsafe fn compress_pre(
 }
 
 #[target_feature(enable = "sse4.1")]
+#[inline]
 pub unsafe fn compress_in_place(
     cv: &mut CVWords,
     block: &[u8; BLOCK_LEN],
@@ -349,6 +350,7 @@ pub unsafe fn compress_in_place(
 }
 
 #[target_feature(enable = "sse4.1")]
+#[inline]
 pub unsafe fn compress_xof(
     cv: &CVWords,
     block: &[u8; BLOCK_LEN],
@@ -568,6 +570,7 @@ unsafe fn load_counters(counter: u64, increment_counter: IncrementCounter) -> (_
 }
 
 #[target_feature(enable = "sse4.1")]
+#[inline]
 pub unsafe fn hash4(
     inputs: &[*const u8; DEGREE],
     blocks: usize,
@@ -659,6 +662,7 @@ pub unsafe fn hash4(
 }
 
 #[target_feature(enable = "sse4.1")]
+#[inline(always)]
 unsafe fn hash1<const N: usize>(
     input: &[u8; N],
     key: &CVWords,
@@ -692,6 +696,7 @@ unsafe fn hash1<const N: usize>(
 }
 
 #[target_feature(enable = "sse4.1")]
+#[inline]
 pub unsafe fn hash_many<const N: usize>(
     mut inputs: &[&[u8; N]],
     key: &CVWords,
diff --git a/src/traits.rs b/src/traits.rs
index 70b1c06..f32db95 100644
--- a/src/traits.rs
+++ b/src/traits.rs
@@ -10,14 +10,14 @@ use digest::generic_array::{typenum::U32, typenum::U64, GenericArray};
 impl digest::HashMarker for Hasher {}
 
 impl digest::Update for Hasher {
-    #[inline]
+    #[inline(always)]
     fn update(&mut self, data: &[u8]) {
         self.update(data);
     }
 }
 
 impl digest::Reset for Hasher {
-    #[inline]
+    #[inline(always)]
     fn reset(&mut self) {
         self.reset(); // the inherent method
     }
@@ -28,14 +28,14 @@ impl digest::OutputSizeUser for Hasher {
 }
 
 impl digest::FixedOutput for Hasher {
-    #[inline]
+    #[inline(always)]
     fn finalize_into(self, out: &mut GenericArray<u8, Self::OutputSize>) {
         out.copy_from_slice(self.finalize().as_bytes());
     }
 }
 
 impl digest::FixedOutputReset for Hasher {
-    #[inline]
+    #[inline(always)]
     fn finalize_into_reset(&mut self, out: &mut GenericArray<u8, Self::OutputSize>) {
         out.copy_from_slice(self.finalize().as_bytes());
         self.reset();
@@ -45,14 +45,14 @@ impl digest::FixedOutputReset for Hasher {
 impl digest::ExtendableOutput for Hasher {
     type Reader = OutputReader;
 
-    #[inline]
+    #[inline(always)]
     fn finalize_xof(self) -> Self::Reader {
         Hasher::finalize_xof(&self)
     }
 }
 
 impl digest::ExtendableOutputReset for Hasher {
-    #[inline]
+    #[inline(always)]
     fn finalize_xof_reset(&mut self) -> Self::Reader {
         let reader = Hasher::finalize_xof(self);
         self.reset();
@@ -61,7 +61,7 @@ impl digest::ExtendableOutputReset for Hasher {
 }
 
 impl digest::XofReader for OutputReader {
-    #[inline]
+    #[inline(always)]
     fn read(&mut self, buffer: &mut [u8]) {
         self.fill(buffer);
     }
@@ -78,7 +78,7 @@ impl crypto_common::BlockSizeUser for Hasher {
 impl digest::MacMarker for Hasher {}
 
 impl digest::KeyInit for Hasher {
-    #[inline]
+    #[inline(always)]
     fn new(key: &digest::Key<Self>) -> Self {
         let key_bytes: [u8; 32] = (*key).into();
         Hasher::new_keyed(&key_bytes)
diff --git a/src/wasm32_simd.rs b/src/wasm32_simd.rs
index f0b5580..2b057aa 100644
--- a/src/wasm32_simd.rs
+++ b/src/wasm32_simd.rs
@@ -358,6 +358,7 @@ fn compress_pre(
 }
 
 #[target_feature(enable = "simd128")]
+#[inline]
 pub fn compress_in_place(
     cv: &mut CVWords,
     block: &[u8; BLOCK_LEN],
@@ -375,6 +376,7 @@ pub fn compress_in_place(
 }
 
 #[target_feature(enable = "simd128")]
+#[inline]
 pub fn compress_xof(
     cv: &CVWords,
     block: &[u8; BLOCK_LEN],
@@ -583,6 +585,7 @@ fn load_counters(counter: u64, increment_counter: IncrementCounter) -> (v128, v1
 }
 
 #[target_feature(enable = "simd128")]
+#[inline]
 pub unsafe fn hash4(
     inputs: &[*const u8; DEGREE],
     blocks: usize,
@@ -674,6 +677,7 @@ pub unsafe fn hash4(
 }
 
 #[target_feature(enable = "simd128")]
+#[inline(always)]
 unsafe fn hash1<const N: usize>(
     input: &[u8; N],
     key: &CVWords,
@@ -705,6 +709,7 @@ unsafe fn hash1<const N: usize>(
 }
 
 #[target_feature(enable = "simd128")]
+#[inline]
 pub unsafe fn hash_many<const N: usize>(
     mut inputs: &[&[u8; N]],
     key: &CVWords,
